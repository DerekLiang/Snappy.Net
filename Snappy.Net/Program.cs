using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Runtime.InteropServices;
using System.Diagnostics;

namespace Snappy.Net
{
	public class Engine
	{
		[DllImport("Snappy.dll")]
		// ------------------------------------------------------------------------
		// Lower-level character array based routines.  May be useful for
		// efficiency reasons in certain circumstances.
		// ------------------------------------------------------------------------

		// REQUIRES: "compressed" must point to an area of memory that is at
		// least "MaxCompressedLength(input_length)" bytes in length.
		//
		// Takes the data stored in "input[0..input_length]" and stores
		// it in the array pointed to by "compressed".
		//
		// "*compressed_length" is set to the length of the compressed output.
		//
		// Example:
		//    char* output = new char[snappy::MaxCompressedLength(input_length)];
		//    size_t output_length;
		//    RawCompress(input, input_length, output, &output_length);
		//    ... Process(output, output_length) ...
		//    delete [] output;
		static extern void RawCompress(byte[] input, IntPtr input_length, byte[] compressed, ref IntPtr compressed_length);

		[DllImport("Snappy.dll")]
		// Given data in "compressed[0..compressed_length-1]" generated by
		// calling the Snappy::Compress routine, this routine
		// stores the uncompressed data to
		//    uncompressed[0..GetUncompressedLength(compressed)-1]
		// returns false if the message is corrupted and could not be decrypted
		static extern bool RawUncompress(byte[] compressed, IntPtr compressed_length, byte[] uncompressed);

		//[DllImport("Snappy.dll")]
		// Given data from the byte source 'compressed' generated by calling
		// the Snappy::Compress routine, this routine stores the uncompressed
		// data to
		//    uncompressed[0..GetUncompressedLength(compressed,compressed_length)-1]
		// returns false if the message is corrupted and could not be decrypted
		//static extern bool RawUnCompress(byte[] compressed, byte[] uncompressed);

		[DllImport("Snappy.dll")]
		// Returns the maximal size of the compressed representation of
		// input data that is "source_bytes" bytes in length;
		static extern IntPtr MaxCompressedLength(IntPtr source_bytes);

		[DllImport("Snappy.dll")]
		// REQUIRES: "compressed[]" was produced by RawCompress() or Compress()
		// Returns true and stores the length of the uncompressed data in
		// *result normally.  Returns false on parsing error.
		// This operation takes O(1) time.
		static extern bool GetUncompressedLength(byte[] compressed, IntPtr compressed_length, ref IntPtr result);

		[DllImport("Snappy.dll")]
		// Returns true iff the contents of "compressed[]" can be uncompressed
		// successfully.  Does not return the uncompressed data.  Takes
		// time proportional to compressed_length, but is usually at least
		// a factor of four faster than actual decompression.
		static extern bool IsValidCompressedBuffer(byte[] compressed, IntPtr compressed_length);

		static public byte[] Compress(byte[] src)
		{
			IntPtr max_length = MaxCompressedLength( (IntPtr)src.Length );

			byte[] compressed = new byte[max_length.ToInt32()];

			IntPtr compressed_length = IntPtr.Zero;
			RawCompress(src, (IntPtr)src.Length, compressed, ref compressed_length);

			byte[] result = new byte[compressed_length.ToInt32()];

			Array.Copy(compressed, result, compressed_length.ToInt32());

			return result;
		}
		
		static public byte[] Uncompress(byte[] compressed)
		{
			IntPtr uncompressed_length = IntPtr.Zero;

			if (!GetUncompressedLength(compressed, (IntPtr)compressed.Length, ref uncompressed_length))
				throw new Exception("TODO");
			byte[] result = new byte[uncompressed_length.ToInt32()];

			if (!RawUncompress(compressed, (IntPtr) compressed.Length, result))
				throw new Exception("Data is corrupt");

			return result;
		}

		static void Main(string[] args)
		{
			StringBuilder sb = new StringBuilder();

			for (int i = 0, l = 1000000; i < l; i++)
			{
				sb.Append("snappy ");
			}

			byte[] data = Encoding.Default.GetBytes(sb.ToString());

			byte[] compressed = Compress(data);
			Console.WriteLine("Original-Length: " + data.Length);
			Console.WriteLine("Compressed-Length: " + compressed.Length);

			byte[] uncompressed = Uncompress(compressed);
			Console.WriteLine("Decompressed-Length: " + uncompressed.Length);

			string str2 = Encoding.Default.GetString(uncompressed);
			Console.WriteLine("Equality: " + str2.Equals(sb.ToString()));

			Console.WriteLine("benchmark...");


			Stopwatch stopWatch = new Stopwatch();
			int count = 0;
			stopWatch.Start();
			while (stopWatch.ElapsedMilliseconds < 2000)
			{
				Compress(data);
				count++;
			}
			stopWatch.Stop();
			Console.WriteLine("Compression throughput is (KByte/sec): " + data.Length*count/ stopWatch.ElapsedMilliseconds);

			count = 0;
			stopWatch.Reset();
			stopWatch.Start();
			while (stopWatch.ElapsedMilliseconds < 2000)
			{
				Uncompress(compressed);
				count++;
			}
			stopWatch.Stop();
			Console.WriteLine("Uncompression throughput is (KByte/sec): " + data.Length * count / stopWatch.ElapsedMilliseconds);

			Console.WriteLine("All running OK");
			Console.ReadKey();
		}
	}
}
